说一下项目里有做过哪些 webpack 上的优化（字节跳动）

> 参考答案：
>
> 1. 对传输性能的优化
>
>    - 压缩和混淆
>
>      使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积
>
>    - tree shaking
>
>      项目中尽量使用 ESM，可以有效利用 tree shaking 优化，降低包体积
>
>    - 抽离公共模块
>
>      将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。
>
>      具体方式有多种，比如 dll、splitChunks
>
>    - 异步加载
>
>      对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。
>
>      这样可以显著提高页面的响应速度，在单页应用中尤其有用。
>
>    - CDN
>
>      对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度
>
>    - gzip
>
>      目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩
>
>    - 环境适配
>
>      有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。
>
> 2. 对打包过程的优化
>
>    - noParse
>
>      很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库
>
>    - externals
>
>      对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包
>
>    - 限制 loader 的范围
>
>      在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉
>
>    - 开启 loader 缓存
>
>      可以利用`cache-loader`缓存 loader 的编译结果，避免在源码没有变动时反复编译
>
>    - 开启多线程编译
>
>      可以利用`thread-loader`开启多线程编译，提升编译效率
>
>    - 动态链接库
>
>      对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库
>
> 3. 对开发体验的优化
>
>    - lint
>
>      使用 eslint、stylelint 等工具保证团队代码风格一致
>
>    - HMR
>
>      使用热替换避免页面刷新导致的状态丢失，提升开发体验